<!DOCTYPE html><html>

<?php 
$title = "Julia 1.0";
$keywords = "";
$description = "";
$active_menu = "blog";
require_once('../_common/head.html'); ?>
<body>
  

  <?php require_once('../_common/nav.html'); ?>

<br><br>

<div class="container">

  <div class="row">
    <div class="col-12 col-lg-8 offset-lg-2">
      <h1></h1>

<div id="blogpost">
  <h1>Julia 1.0</h1>

  <p class="metadata">
    <span class="timestamp">08 Aug 2018</span>
    
  </p>

  <p>La anticipada liberación de la versión 1.0 de <a href="https://julialang.org">Julia</a> es la culminación
de casi una década de trabajo de construir un lenguaje para programadores ambiciosos. JuliaCon2018
celebró la ocasión con un evento donde la comunidad oficialmente <a href="https://www.youtube.com/watch?v=1jN5wKvN-Uk#t=3850">lanzó conjuntamente la versión
1.0.0.</a></p>

<p>El primer comunicado <a href="https://julialang.org/blog/2012/02/why-we-created-julia">público</a> de Julia fue hecho con
número de exigencias sobre el lenguaje:</p>

<blockquote>
  <p>Queremos un lenguaje que sea de código abierto, con licencia liberal. Queremos la velocidad de C
con el dinamismo de Ruby. Queremos un lenguaje que sea homoicónico, con macros verdaderos tipo Lisp,
pero con notación matemática, obvia y familiar como Matlab. Queremos algo usable
para programación general como Python, tan fácil para estadística como R, tan natural para procesamiento
de cadenas como Perl, tan potente para álgebra lineal como Matlab, tan bueno uniendo programas juntos como
un shell. Algo que sea sumamente sencillo de aprender, pero que mantenga a los hackers más serios
felices. Queremos que sea interactivo y que sea compilado.</p>
</blockquote>

<p>Una comunidad vibrante y fructífera ha crecido alrededor de este lenguaje, con gente de
todo el mundo iterativamente refinando y reformulado Julia para cumplir su meta. Más de 700
personas han contribuido a Julia en sí y aún más gente han hecho miles de asombrosos paquetes de código abierto. En resumen, hemos construido un lenguaje que es:</p>

<ul>
  <li><strong>Rápido</strong>: Julia fue diseñado desde el principio para tener alto rendimiento. Los programas de Julia
se compilan a código nativo eficiente para muchas plataformas por medio de LLVM.</li>
  <li><strong>General</strong>: Usa despacho múltiple como paradigma, facilitando expresar muchos patrones de
la programación orientada a objetos ó programación funcional. La biblioteca estándar provee
I/O asíncrono, control de procesos, logging, perfiles, un administrador de paquetes y más.</li>
  <li><strong>Técnico</strong>: Sobresale en cómputo numérico con una sintaxis excelente para las matemáticas,
amplio soporte para muchos tipos de datos, y pararelismo incluido por default. Su despacho múltiple
es un embone natural para definir tipos de datos numéricos y de arreglos.</li>
  <li><strong>Opcionalmente tipado</strong>: Julia tiene un lenguaje rico para describir tipos de datos, y la declaración
de tipos puede ser usada para clarificar y solidificar programas.</li>
  <li><strong>Componible</strong>: Los paquetes de Julia se pueden simultáneamente sin dificultad. Matrices de cantidades
unitarias, ó datos de columnas tabuladas de divisas y colores – todo funciona – y a buena velocidad.</li>
</ul>

<p>Prueba Julia bajando la <a href="https://julialang.org/downloads/">versión 1.0 ahora</a>. Si estás actualizando
código de Julia 0.6 o versiones anteriores, te recomendamos que primero uses la versión 0.7 como transición. Una vez
que tu código esté libre de advertencias (<em>warnings</em>), puedes cambiarlo a 1.0 sin ninguna pérdida de funcionalidad. Los paquetes registrados 
están aprovechando esta etapa de transición y liberando sus actualizaciones compatibles con 1.0.</p>

<p>La ventaja más importante de Julia 1.0 es, por supuesto, es un compromiso de estabilidad de API:
El código que escribes para Julia 1.0 seguirá funcionando en 1.1, 1.2, etc. El lenguaje está “completo”.
Los desarrolladores principales y la comunidad pueden enfocarse en la paquetería, herramientas, y nuevas
funcionalidades construidas sobre una base sólida.</p>

<p>Sin embargo, Julia 1.0 no es solamente sobre estabilidad, también introduce nuevas y poderosas innovaciones del lenguaje.
Algunas de estas novedades desde la versión 0.6 incluyen:</p>

<ul>
  <li>
    <p>Un nuevo e incluido <a href="https://docs.julialang.org/en/latest/stdlib/Pkg/">administrador de paquetes</a>
trae enormes mejoras de rendimiento y facilita más que nunca la instalación de paquetes y sus 
dependencias. También soporta ambientes particulares para cada proyecto y registros de estado exactos para
una aplicación para poderla compartir con los demás - y tu futuro yo. Finalmente, el rediseño también introduce
soporte integrado para paquetes privados y repositorios. Tú puedes instalar y administrar paqueterías
privadas con las mismas herramientas que el ecosistema de paquetería abierta. La <a href="https://www.youtube.com/watch?v=GBi__3nF-rM">presentación de
JuliaCon</a> resume el nuevo diseño y capacidades.</p>
  </li>
  <li>
    <p>Julia tiene una nueva <a href="https://julialang.org/blog/2018/06/missing">representación canónica para valores faltantes</a>.
Poder representar y trabajar con datos faltantes es fundamental para estadísticas y ciencias de datos. En estilo Juliano,
la nueva solución es general, componible y rápida. Cualquier colección general puede eficientemente
soportar valores faltantes simplemente al permitir que elementos incluyan el valor predefinido <code class="highlighter-rouge">missing</code>. 
El rendimiento de dadas colecciones “tipadas como uniones” hubieran sido demasiado lento en versiones anteriores
de Julia, pero mejoras en el compilador permiten ahora que en Julia sea comparable a la velocidad de valores faltantes 
en C ó C++ en otros sistemas, mientras que sigue siendo mucho más general y flexible.</p>
  </li>
  <li>
    <p>El tipo <code class="highlighter-rouge">String</code> ahora puede contener datos arbitrarios. Tu programa no fallará después de horas ó días porque
un solo byte de Unicode era inválido. Todos los datos de cadenas de caracteres son preservados mientras que se indica cuáles caracteres
son válidos o inválidos, permitiendo que sus aplicaciones sean conveniente y seguramente usadas en datos reales con todas sus
inevitables complicaciones.</p>
  </li>
  <li>
    <p>“Broadcasting” ya es una ventaja clave con sintaxis conveniente – y ahora es más poderosa que nunca. En 
Julia 1.0 es fácil <a href="https://julialang.org/blog/2018/05/extensible-broadcast-fusion">extender broadcasting a tipos del usuario</a> e implementarlo
en cálculos optimizados para GPUs y hardware vectorizado, pavimentando el camino para aún más mejoras en el futuro.</p>
  </li>
  <li>
    <p>Las tuplas con nombre son rasgo nuevo que permite representar y accesar datos por nombre y de manera eficiente. Puedes, por ejemplo,
representar una hilera de datos como <code class="highlighter-rouge">row =
(name="Julia", version=v"1.0.0", releases=8)</code> y accesar su columna <code class="highlighter-rouge">version</code> como
<code class="highlighter-rouge">row.version</code> con la misma velocidad que el inconveniente <code class="highlighter-rouge">row[2]</code>.</p>
  </li>
  <li>
    <p>El operador punto ahora puede ser sobrecargado, permitiendo así que tipos usen la sintaxis <code class="highlighter-rouge">obj.propiedad</code> para
comportamientos que no sea accesar o fijar campos de structs. Esto es especialmente útil para facilitar
la interoperabilidad con lenguajes basados en clases como Python y Java. Esto también permite sobrecargar la
sintaxis para obtener una columna de datos y que empate con la de tuplas nombradas: puedes escribir
<code class="highlighter-rouge">tabla.versión</code> para accesar la columna <code class="highlighter-rouge">versión</code> de una tabla ó <code class="highlighter-rouge">row.versión</code> accesa el campo
<code class="highlighter-rouge">versión</code> de una sola hilera.</p>
  </li>
  <li>
    <p>El optimizador de Julia se ha vuelto mucho más listo en demasiadas maneras como para aquí enlistarlas, pero
algunas de ellas vale la pena mencionar. El optimizador ahora nos permite propagar constantes a través de llamadas
a funciones, permitiendo mucha mejor eliminación de código muerto y evaluación estática que antes. El compilador
ahora también es mucho mejor evitando alocaciones de <em>wrappers</em> efímeros alrededor de objetos longevos, permitiendo
a los programadores a usar abstracciones de alto nivel sin costo de rendimiento.</p>
  </li>
  <li>
    <p>Los constructores de tipos paramétricos ahora se llaman con la misma sintaxis con la que se declaran. Esto
elimina una barrera rebuscada pero confusa de sintaxis.</p>
  </li>
  <li>
    <p>El protocolo de iteración ha sido completamente rediseñado para facilitar implementar muchos tipos de
iterables. En vez de —<code class="highlighter-rouge">start</code>, <code class="highlighter-rouge">next</code>, <code class="highlighter-rouge">done</code>—uno ahora define métodos de uno y dos argumentos para la función
<code class="highlighter-rouge">iterate</code>. Esto frecuentemente permite que la iteración se defina con un sólo método y un valor por default para 
el estado inicial. Aunado a lo anterior, es posible implementar iteradores que solo saben si han terminado
una vez que han intentado y fallado en producir un valor – justo el tipo de iteradores que son ubicuos en I/O,
producidores/consumidores, etc. Julia puede expresar estos iteradores directa y correctamente.</p>
  </li>
  <li>
    <p>Las reglas de alcance han sido simplificadas. Las construcciones que introducen alcances locales ahora lo hacen
de manera consistente, sin importar los enlaces globales para nombre preexistentes o no. Esto elimina la distinción de
alcances “duros/suaves” que previamente existía y significa que Julia siempre puede determinar estáticamente si variables son
locales o globales.</p>
  </li>
  <li>
    <p>El lenguaje en sí es significativamente más esbelto, con muchos componentes siendo escindidos a paquetes en la
“biblioteca estándar” que es liberada con Julia pero que no es parte del lenguaje “base”. Si los necesitas, solo
necesitas importar (sin instalar) pero no estarás coaccionada a hacerlo. En el futuro, esto permitirá que las bibliotecas
estándar sean versionadas y actualizadas independientemente de Julia, permitiendo que evolucionen y se mejoren más rápido.</p>
  </li>
  <li>
    <p>Hemos revisado extensamente todas las APIs de Julia para mejorar la consistencia y usabilidad. Muchos nombres 
tradicionales rebuscados y patrones ineficientes han sido renombrados o refactorizados para empatar elegantemente con las capacidades de Julia.
Esto ha promovido cambios para trabajar con colecciones de manera más consistente y coherente, y asegurar que el orden de los argumentos
sea un estándar consistente a lo largo del lenguaje, y para incorporar los (ahora más rápidos) argumentos “keyword” en las APIs
apropiadas.</p>
  </li>
  <li>
    <p>Un gran número de paquetería externa ha sido específicamente construida alrededor de las ventajas de Julia 1.0, tales como:</p>
    <ul>
      <li>
        <p>El ecosistema de procesamiento y manipulación de manejo de datos fue reorganizado alrededor de los valores faltantes.</p>
      </li>
      <li>
        <p><a href="https://github.com/jrevels/Cassette.jl">Cassette.jl</a> provee un poderoso mecanismo para inyectar pases de transformación de
  código al compilador de Julia, permitiendo análisis post-hoc y extensión de código existente. Además de la instrumentación para
  programadores como un debugger y un profiler, esto también puede implementar diferenciación automática para tareas de <em>machine learning</em>.</p>
      </li>
      <li>
        <p>Se ha incrementado enormemente el soporte para arquitecturas heterogéneas y se ha desacoplado aún más del funcionamiento
  interno del compilador. Los Intel KNLs funcionan en Julia. Los GPUs de Nvidia son programados usando <a href="https://github.com/JuliaGPU/CUDAnative.jl">CUDANative.jl</a>
  y un port para los TPUs de Google está siendo desarrollado.</p>
      </li>
    </ul>
  </li>
</ul>

<p>Éstas son solo algunas de las mejoras. Para una lista completa de los cambios, lee el archivo <a href="https://docs.julialang.org/en/release-0.7/NEWS/">0.7 NEWS</a>. En el post 
original <a href="https://julialang.org/blog/2012/02/why-we-created-julia">“Why We Created Julia” blog
post</a> en 2012, escribimos</p>

<blockquote>
  <p>No está completo, pero es tiempo de liberar la versión 1.0 del lenguaje que creamos llamado
<a href="https://julialang.org">Julia</a>.</p>
</blockquote>

<p>Tal vez nos adelantamos un poco con la versión 1.0, pero el tiempo finalmente ha llegado y es un release fantástico.
Estamos verdaderamente orgullosos de lo que hemos logrado con los miles de programadores que han contribuido en tantas maneras a este lenguaje
verdaderamente moderno para programación general y numérica.</p>


</div>



</div>
</div>
</div>

<br>

  <?php require_once('../_common/foot.html'); ?>



</body></html>